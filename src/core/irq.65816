/*
a little reconfigurable irq handler
problem is that normal object model and irqs run asynchronously, so you can't just call object code without side-effects(the object might be executing code or being moved around currently)
thats why objects can register a callback
*/

.include "src/core/irq.h"

.section "irq stuff"


/**
* stops irqs from happening immediately
*/
core.irq.stop:
  php
  sep #$20

  lda.l GLOBAL.interruptFlags
  and #(NMITIMEN_Y_IRQ_ENABLE | NMITIMEN_X_IRQ_ENABLE) ~$ff
  sta.l GLOBAL.interruptFlags
  sta.l NMITIMEN

  plp
  rts

core.irq.init:
  AX16
  lda #core.irq.callback.void
  sta.l GLOBAL.irq.callback
  jmp core.irq.stop

/**
*
*/
core.irq.callback.void:
  TRIGGER_ERROR E_NoIrqCallback


core.irq.play:
  ;switch to 16bit a/x in order to preserve everything and not just 8bit of the accu
	rep #$39		
	pha
	phx
	phy
	phd
	phb	
    pea VARS
    pld
    pea RAM | (RAM << 8)
    plb
    plb

    jsr core.nmi.stop

    ;jump to registered callback if valid
    rep #$31
    lda.w GLOBAL.irq.callback
    tax
    dex
    dex
    dex
    dex
    dex
    dex
    lda.l (ROM << 16),x
    cmp #IRQ_MAGIC
    beq +
      TRIGGER_ERROR E_BadIrqCallback

+
    lda.w GLOBAL.irq.callback
    dec a
    pea _return-1   ;push return adress
    pha ;push callback adress
    rts ;this is actually a jump to subroutine on stack, then return

_return:


    jsr core.nmi.start
    sep #$20

    lda.l TIMEUP
    rep #$39

    plb
    pld
    ply
    plx
    pla
    rti

.ends
